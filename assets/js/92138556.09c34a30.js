"use strict";(self.webpackChunk=self.webpackChunk||[]).push([[590],{784:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>a,contentTitle:()=>l,default:()=>h,frontMatter:()=>i,metadata:()=>s,toc:()=>d});const s=JSON.parse('{"id":"examples/with-flutter-bloc","title":"Flutter Bloc Query","description":"We will use the Json Placeholder Api with a time delay to demonstrate","source":"@site/docs/examples/02-with-flutter-bloc.md","sourceDirName":"examples","slug":"/examples/with-flutter-bloc","permalink":"/examples/with-flutter-bloc","draft":false,"unlisted":false,"editUrl":"https://github.com/D-James-GH/cached_query/tree/main/docs/docs/examples/02-with-flutter-bloc.md","tags":[],"version":"current","sidebarPosition":2,"frontMatter":{},"sidebar":"examples","previous":{"title":"Simple Query Example","permalink":"/examples/simple-query"},"next":{"title":"Infinite List","permalink":"/examples/infinite-query"}}');var r=n(4848),o=n(8453);const i={},l="Flutter Bloc Query",a={},d=[{value:"How to integrate?",id:"how-to-integrate",level:2},{value:"Map the query state to bloc state.",id:"map-the-query-state-to-bloc-state",level:3},{value:"Pro",id:"pro",level:4},{value:"Con",id:"con",level:4},{value:"Pass the query to an <code>QueryBuilder</code> in the UI.",id:"pass-the-query-to-an-querybuilder-in-the-ui",level:3},{value:"Pro",id:"pro-1",level:4},{value:"Con",id:"con-1",level:4},{value:"The Setup",id:"the-setup",level:2},{value:"Creating the Query",id:"creating-the-query",level:2},{value:"Post Model",id:"post-model",level:2},{value:"Bloc Events",id:"bloc-events",level:2},{value:"Option 1 - Passing the query to the UI",id:"option-1---passing-the-query-to-the-ui",level:2},{value:"Bloc State",id:"bloc-state",level:3},{value:"The Bloc",id:"the-bloc",level:3},{value:"The UI",id:"the-ui",level:3},{value:"Post Widget",id:"post-widget",level:3},{value:"Post Page",id:"post-page",level:3},{value:"Option 2 - Mapping the Query State to Bloc State",id:"option-2---mapping-the-query-state-to-bloc-state",level:2},{value:"Bloc State",id:"bloc-state-1",level:3},{value:"The Bloc",id:"the-bloc-1",level:3},{value:"The UI",id:"the-ui-1",level:3},{value:"Post Page",id:"post-page-1",level:3},{value:"Summary",id:"summary",level:2}];function c(e){const t={a:"a",admonition:"admonition",code:"code",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",li:"li",p:"p",pre:"pre",ul:"ul",...(0,o.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(t.header,{children:(0,r.jsx)(t.h1,{id:"flutter-bloc-query",children:"Flutter Bloc Query"})}),"\n",(0,r.jsxs)(t.p,{children:["We will use the ",(0,r.jsx)(t.a,{href:"https://jsonplaceholder.typicode.com/",children:"Json Placeholder Api"})," with a time delay to demonstrate\ncached data."]}),"\n",(0,r.jsxs)(t.p,{children:["The source code for this example can be found here: ",(0,r.jsx)(t.a,{href:"https://github.com/D-James-GH/cached_query/tree/main/examples/simple_caching_with_bloc",children:"https://github.com/D-James-GH/cached_query/tree/main/examples/simple_caching_with_bloc"})]}),"\n",(0,r.jsx)(t.p,{children:"For this example we will walk through the simplest form of caching with Cached Query and Flutter Bloc together. Flutter bloc is a popular implementation of the bloc pattern. It is very useful for keeping app architecture structured as team size and app size grows."}),"\n",(0,r.jsx)(t.p,{children:"Using Flutter Bloc along side Cached Query was an important consideration when creating this package. However, following example should be transferable to any app architecture."}),"\n",(0,r.jsx)(t.h2,{id:"how-to-integrate",children:"How to integrate?"}),"\n",(0,r.jsx)(t.p,{children:"There are two implementation options to consider when using Cached Query with Flutter Bloc."}),"\n",(0,r.jsx)(t.h3,{id:"map-the-query-state-to-bloc-state",children:"Map the query state to bloc state."}),"\n",(0,r.jsxs)(t.p,{children:["This option uses listens to the ",(0,r.jsx)(t.code,{children:"Query"})," stream in the bloc and maps incoming query states into outgoing bloc states."]}),"\n",(0,r.jsx)(t.h4,{id:"pro",children:"Pro"}),"\n",(0,r.jsxs)(t.ul,{children:["\n",(0,r.jsx)(t.li,{children:"Easy to integrate into existing apps as only the repository and bloc layers need adjusting, the presentation layer will remain the same."}),"\n"]}),"\n",(0,r.jsx)(t.h4,{id:"con",children:"Con"}),"\n",(0,r.jsxs)(t.ul,{children:["\n",(0,r.jsxs)(t.li,{children:["The query key will always have a subscriber if the bloc is still in memory. When using a ",(0,r.jsx)(t.code,{children:"QueryBuilder"})," the subscriber will be removed as soon as the component is removed from the widget tree."]}),"\n"]}),"\n",(0,r.jsxs)(t.h3,{id:"pass-the-query-to-an-querybuilder-in-the-ui",children:["Pass the query to an ",(0,r.jsx)(t.code,{children:"QueryBuilder"})," in the UI."]}),"\n",(0,r.jsxs)(t.p,{children:["This option passes the ",(0,r.jsx)(t.code,{children:"Query"})," through to the UI an uses the ",(0,r.jsx)(t.code,{children:"QueryBuilder"})," to listen to state updates."]}),"\n",(0,r.jsx)(t.h4,{id:"pro-1",children:"Pro"}),"\n",(0,r.jsxs)(t.ul,{children:["\n",(0,r.jsxs)(t.li,{children:["As soon as the ",(0,r.jsx)(t.code,{children:"QueryBuilder"})," is removed from the widget tree the subscriber is removed, allowing for more effective cache management."]}),"\n"]}),"\n",(0,r.jsx)(t.h4,{id:"con-1",children:"Con"}),"\n",(0,r.jsxs)(t.ul,{children:["\n",(0,r.jsxs)(t.li,{children:["Needs an Infinite Query to be used directly in the UI, either with a ",(0,r.jsx)(t.code,{children:"QueryBuilder"})," or by listening/disposing of the stream."]}),"\n"]}),"\n",(0,r.jsx)(t.h2,{id:"the-setup",children:"The Setup"}),"\n",(0,r.jsx)(t.p,{children:"Install the package."}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{children:"flutter pub add cached_query_flutter\n"})}),"\n",(0,r.jsx)(t.p,{children:"The setup is optional but to take full advantage of cached query we need to call the config function as early as possible."}),"\n",(0,r.jsxs)(t.p,{children:["The ",(0,r.jsx)(t.code,{children:"config"})," function lets cached query know that it should re-fetch queries if the connectivity is established and if\nthe app comes back into view."]}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-dart",children:"void main() {\n  WidgetsFlutterBinding.ensureInitialized();\n  CachedQuery.instance.configFlutter(\n    config: QueryConfigFlutter(\n      refetchOnResume: true,\n      refetchOnConnection: true,\n    ),\n  );\n  runApp(const MyApp());\n}\n"})}),"\n",(0,r.jsx)(t.p,{children:"The main app will just consist of one page."}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-dart",children:"class MyApp extends StatelessWidget {\n  const MyApp({Key? key}) : super(key: key);\n  // This widget is the root of your application.\n  @override\n  Widget build(BuildContext context) {\n    return const MaterialApp(\n      title: 'Flutter Demo',\n      home: PostPage(),\n    );\n  }\n}\n"})}),"\n",(0,r.jsx)(t.h2,{id:"creating-the-query",children:"Creating the Query"}),"\n",(0,r.jsxs)(t.p,{children:["We create a service function which returns a ",(0,r.jsx)(t.code,{children:"Query"})," for us to display. The ",(0,r.jsx)(t.code,{children:"queryFn"})," is where the logic for the request\nneeds to go. This function will be first called when a listener is added to the query stream."]}),"\n",(0,r.jsx)(t.p,{children:"As the app is going to fetch a post by an id we have to add the id to the query key as well. The helper function below\nreturns a key which includes the post id."}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-dart",children:'String postKey(int id) => "postKey$id";\n'})}),"\n",(0,r.jsx)(t.p,{children:"Each time the query key changes a new query will be created."}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-dart",children:"\nQuery<PostModel> getPostById(int id) {\n  return Query<PostModel>(\n    key: postKey(id),\n    queryFn: () async {\n      final uri = Uri.parse(\n        'https://jsonplaceholder.typicode.com/posts/$id',\n      );\n      final res = await http.get(uri);\n      return Future.delayed(\n        const Duration(milliseconds: 500),\n        () => PostModel.fromJson(\n          jsonDecode(res.body) as Map<String, dynamic>,\n        ),\n      );\n    },\n  );\n}\n"})}),"\n",(0,r.jsx)(t.h2,{id:"post-model",children:"Post Model"}),"\n",(0,r.jsx)(t.p,{children:"This post model is a simple object that we serialize the json payload into."}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-dart",children:'class PostModel {\n  final String title;\n  final int id;\n  final String body;\n  final int userId;\n\n  PostModel({\n    required this.title,\n    required this.id,\n    required this.body,\n    required this.userId,\n  });\n\n  factory PostModel.fromJson(Map<String, dynamic> json) => PostModel(\n    title: json["title"],\n    body: json["body"],\n    id: json["id"],\n    userId: json["userId"],\n  );\n}\n'})}),"\n",(0,r.jsx)(t.h2,{id:"bloc-events",children:"Bloc Events"}),"\n",(0,r.jsx)(t.p,{children:"The events will be the same whether you are mapping the query to bloc state or not.\nWe have one that fetches a new query by it's id and another that refreshes the current query."}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-dart",children:"abstract class PostEvent {}\n\nclass PostFetched extends PostEvent {\n  final int id;\n  PostFetched(this.id);\n}\n\nclass PostRefreshed extends PostEvent {}\n"})}),"\n",(0,r.jsx)(t.h2,{id:"option-1---passing-the-query-to-the-ui",children:"Option 1 - Passing the query to the UI"}),"\n",(0,r.jsx)(t.h3,{id:"bloc-state",children:"Bloc State"}),"\n",(0,r.jsx)(t.p,{children:"The Bloc state will differ depending on whether you are mapping the query state in the bloc or not."}),"\n",(0,r.jsx)(t.p,{children:"If you would prefer to pass the query through to the UI then the state will hold the current query."}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-dart",children:"class PostWithBuilderState extends Equatable {\n  final int currentId;\n  final Query<PostModel> postQuery;\n\n  const PostWithBuilderState({\n    required this.currentId,\n    required this.postQuery,\n  });\n\n  @override\n  List<Object?> get props => [postQuery, currentId];\n}\n"})}),"\n",(0,r.jsx)(t.h3,{id:"the-bloc",children:"The Bloc"}),"\n",(0,r.jsx)(t.p,{children:"When passing the query through to the UI the bloc is very simple. It simply needs to keep track of the current post id and pass through the new query when the current id changes."}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-dart",children:"class PostWithBuilderBloc\n    extends Bloc<PostWithBuilderEvent, PostWithBuilderState> {\n  PostWithBuilderBloc()\n      : super(PostWithBuilderState(currentId: 50, postQuery: getPostById(50))) {\n    on<PostWithBuilderFetched>(_onPostFetched);\n    on<PostWithBuilderRefreshed>(_onPostRefreshed);\n  }\n\n  FutureOr<void> _onPostFetched(\n    PostWithBuilderFetched event,\n    Emitter<PostWithBuilderState> emit,\n  ) {\n    final res = getPostById(event.id);\n    emit(PostWithBuilderState(currentId: event.id, postQuery: res));\n  }\n\n  FutureOr<void> _onPostRefreshed(\n    PostWithBuilderRefreshed event,\n    Emitter<PostWithBuilderState> emit,\n  ) {\n    getPostById(state.currentId).refetch();\n  }\n}\n"})}),"\n",(0,r.jsx)(t.h3,{id:"the-ui",children:"The UI"}),"\n",(0,r.jsxs)(t.p,{children:["When passing the query through we will use the ",(0,r.jsx)(t.code,{children:"QueryBuilder"})," to update the UI."]}),"\n",(0,r.jsx)(t.h3,{id:"post-widget",children:"Post Widget"}),"\n",(0,r.jsxs)(t.p,{children:["The Post widget will be take a ",(0,r.jsx)(t.code,{children:"PostModel"})," and display it."]}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-dart",children:'class Post extends StatelessWidget {\n  final PostModel post;\n\n  const Post({super.key, required this.post});\n\n  @override\n  Widget build(BuildContext context) {\n    return Container(\n      margin: const EdgeInsets.all(10),\n      child: Column(\n        children: [\n          const Text(\n            "Title",\n            textAlign: TextAlign.center,\n            style: TextStyle(fontSize: 20),\n          ),\n          Text(\n            post.title,\n            textAlign: TextAlign.center,\n          ),\n          const Text(\n            "Body",\n            textAlign: TextAlign.center,\n            style: TextStyle(fontSize: 20),\n          ),\n          Text(\n            post.body,\n            textAlign: TextAlign.center,\n          ),\n        ],\n      ),\n    );\n  }\n}\n'})}),"\n",(0,r.jsx)(t.h3,{id:"post-page",children:"Post Page"}),"\n",(0,r.jsx)(t.p,{children:"The post page utilises a combination of the query builder and bloc builder to update the UI."}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-dart",children:'class PostWithBuilderPage extends StatelessWidget {\n  const PostWithBuilderPage({Key? key}) : super(key: key);\n\n  @override\n  Widget build(BuildContext context) {\n    return BlocProvider(\n      create: (context) =>\n          PostWithBuilderBloc()..add(const PostWithBuilderFetched(50)),\n      child: Builder(builder: (context) {\n        return Scaffold(\n          appBar: AppBar(\n            centerTitle: true,\n            title: BlocSelector<PostWithBuilderBloc, PostWithBuilderState,\n                Query<PostModel>?>(\n              selector: (state) => state.postQuery,\n              builder: (context, query) {\n                if (query == null) return const SizedBox();\n                return QueryBuilder(\n                  query: query,\n                  builder: (context, state) {\n                    return Text(\n                      state.status == QueryStatus.loading ? "loading..." : "",\n                    );\n                  },\n                );\n              },\n            ),\n            actions: [\n              IconButton(\n                icon: const Icon(Icons.refresh),\n                onPressed: () => context\n                    .read<PostWithBuilderBloc>()\n                    .add(const PostWithBuilderRefreshed()),\n              )\n            ],\n          ),\n          body: Center(\n            child: Column(\n              children: [\n                BlocBuilder<PostWithBuilderBloc, PostWithBuilderState>(\n                  builder: (context, state) {\n                    final currentId = state.currentId;\n                    return Row(\n                      mainAxisAlignment: MainAxisAlignment.center,\n                      children: [\n                        IconButton(\n                          onPressed: () => context\n                              .read<PostWithBuilderBloc>()\n                              .add(PostWithBuilderFetched(currentId - 1)),\n                          icon: const Icon(Icons.arrow_left),\n                        ),\n                        Text(currentId.toString()),\n                        IconButton(\n                          onPressed: () => context\n                              .read<PostWithBuilderBloc>()\n                              .add(PostWithBuilderFetched(currentId + 1)),\n                          icon: const Icon(Icons.arrow_right),\n                        ),\n                      ],\n                    );\n                  },\n                ),\n                BlocSelector<PostWithBuilderBloc, PostWithBuilderState,\n                    Query<PostModel>>(\n                  selector: (state) => state.postQuery,\n                  builder: (context, query) {\n                    return QueryBuilder(\n                      query: query,\n                      builder: (context, state) {\n                        if (state.data == null) {\n                          return const SizedBox();\n                        }\n                        return Post(post: state.data!);\n                      },\n                    );\n                  },\n                ),\n              ],\n            ),\n          ),\n        );\n      }),\n    );\n  }\n}\n\n'})}),"\n",(0,r.jsx)(t.h2,{id:"option-2---mapping-the-query-state-to-bloc-state",children:"Option 2 - Mapping the Query State to Bloc State"}),"\n",(0,r.jsx)(t.h3,{id:"bloc-state-1",children:"Bloc State"}),"\n",(0,r.jsx)(t.p,{children:"The state of the bloc will contain the id of the current post and the current post. These are stored separately as the id is treated as local state."}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-dart",children:"class PostState extends Equatable {\n  final PostModel? post;\n  final int currentId;\n  final bool isLoading;\n\n  const PostState({this.isLoading = false, this.currentId = 1, this.post});\n\n  @override\n  List<Object?> get props => [post, isLoading, currentId];\n}\n"})}),"\n",(0,r.jsx)(t.h3,{id:"the-bloc-1",children:"The Bloc"}),"\n",(0,r.jsxs)(t.p,{children:["Mapping the query state to bloc state requires Flutter Bloc's ",(0,r.jsx)(t.code,{children:"emit.foreach"}),". The ",(0,r.jsx)(t.code,{children:"emit.foreach"})," function will manage the stream subscription for us."]}),"\n",(0,r.jsx)(t.admonition,{type:"info",children:(0,r.jsxs)(t.p,{children:["It is important to use the ",(0,r.jsx)(t.code,{children:"restartable"})," event transformer from Bloc Concurrency. This makes sure that there is only one query subscription at a time."]})}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-dart",children:"class PostBloc extends Bloc<PostEvent, PostState> {\n  PostBloc() : super(const PostState()) {\n    /// !important: use the restartable transformer to automatically subscribe and\n    /// unsubscribe when a new event comes in.\n    on<PostFetched>(_onFetched, transformer: restartable());\n    on<PostRefreshed>(_onRefresh);\n  }\n\n  FutureOr<void> _onFetched(\n    PostFetched event,\n    Emitter<PostState> emit,\n  ) {\n    return emit.forEach(\n      getPostById(event.id).stream,\n      onData: (queryState) {\n        return PostState(\n          currentId: event.id,\n          post: queryState.data,\n          isLoading: queryState.status == QueryStatus.loading,\n        );\n      },\n    );\n  }\n\n  FutureOr<void> _onRefresh(PostRefreshed event, Emitter<PostState> emit) {\n    getPostById(state.currentId).refetch();\n  }\n}\n"})}),"\n",(0,r.jsxs)(t.p,{children:["The ",(0,r.jsx)(t.code,{children:"onData"})," function will be called whenever the query state is updated. This is where we map the current query state to a bloc state and return it. The listener will stay alive until there is a new ",(0,r.jsx)(t.code,{children:"PostFetched"})," event."]}),"\n",(0,r.jsx)(t.h3,{id:"the-ui-1",children:"The UI"}),"\n",(0,r.jsx)(t.p,{children:"The UI will use the same post widget as option 1."}),"\n",(0,r.jsx)(t.h3,{id:"post-page-1",children:"Post Page"}),"\n",(0,r.jsx)(t.p,{children:"The post page here uses the bloc builder to update the UI. As the query state has already been listened to and mapped we don't need to use the query builder."}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-dart",children:'class PostPage extends StatelessWidget {\n  const PostPage({Key? key}) : super(key: key);\n\n  @override\n  Widget build(BuildContext context) {\n    return BlocProvider(\n      create: (context) => PostBloc()..add(PostFetched(50)),\n      child: Builder(builder: (context) {\n        return Scaffold(\n          appBar: AppBar(\n            centerTitle: true,\n            title: BlocSelector<PostBloc, PostState, bool>(\n              selector: (state) => state.isLoading,\n              builder: (context, isLoading) {\n                return Text(\n                  isLoading ? "loading..." : "",\n                );\n              },\n            ),\n            actions: [\n              IconButton(\n                icon: const Icon(Icons.refresh),\n                onPressed: () => context.read<PostBloc>().add(PostRefreshed()),\n              )\n            ],\n          ),\n          body: Center(\n            child: Column(\n              children: [\n                BlocBuilder<PostBloc, PostState>(\n                  builder: (context, state) {\n                    final currentId = state.currentId;\n                    return Row(\n                      mainAxisAlignment: MainAxisAlignment.center,\n                      children: [\n                        IconButton(\n                          onPressed: () => context\n                              .read<PostBloc>()\n                              .add(PostFetched(currentId - 1)),\n                          icon: const Icon(Icons.arrow_left),\n                        ),\n                        Text(currentId.toString()),\n                        IconButton(\n                          onPressed: () => context\n                              .read<PostBloc>()\n                              .add(PostFetched(currentId + 1)),\n                          icon: const Icon(Icons.arrow_right),\n                        ),\n                      ],\n                    );\n                  },\n                ),\n                BlocSelector<PostBloc, PostState, PostModel?>(\n                  selector: (state) => state.post,\n                  builder: (context, post) {\n                    if (post == null) {\n                      return const SizedBox();\n                    }\n                    return Post(post: post);\n                  },\n                ),\n              ],\n            ),\n          ),\n        );\n      }),\n    );\n  }\n}\n\n'})}),"\n",(0,r.jsx)(t.h2,{id:"summary",children:"Summary"}),"\n",(0,r.jsx)(t.p,{children:"There are two ways to use Cached Query along side Flutter Bloc. Each with their own pros and cons. If you are starting from scratch you get some memory management benefits from passing the query through to the UI. However, if you are bringing Cached Query into an existing app then wrapping an API call with a query then mapping the state is much simpler."})]})}function h(e={}){const{wrapper:t}={...(0,o.R)(),...e.components};return t?(0,r.jsx)(t,{...e,children:(0,r.jsx)(c,{...e})}):c(e)}},8453:(e,t,n)=>{n.d(t,{R:()=>i,x:()=>l});var s=n(6540);const r={},o=s.createContext(r);function i(e){const t=s.useContext(o);return s.useMemo(function(){return"function"==typeof e?e(t):{...t,...e}},[t,e])}function l(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:i(e.components),s.createElement(o.Provider,{value:t},e.children)}}}]);