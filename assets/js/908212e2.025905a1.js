"use strict";(self.webpackChunk=self.webpackChunk||[]).push([[397],{3905:(e,t,n)=>{n.d(t,{Zo:()=>u,kt:()=>m});var o=n(7294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function a(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);t&&(o=o.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,o)}return n}function s(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?a(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):a(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function i(e,t){if(null==e)return{};var n,o,r=function(e,t){if(null==e)return{};var n,o,r={},a=Object.keys(e);for(o=0;o<a.length;o++)n=a[o],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(o=0;o<a.length;o++)n=a[o],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var l=o.createContext({}),d=function(e){var t=o.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):s(s({},t),e)),n},u=function(e){var t=d(e.components);return o.createElement(l.Provider,{value:t},e.children)},c={inlineCode:"code",wrapper:function(e){var t=e.children;return o.createElement(o.Fragment,{},t)}},p=o.forwardRef((function(e,t){var n=e.components,r=e.mdxType,a=e.originalType,l=e.parentName,u=i(e,["components","mdxType","originalType","parentName"]),p=d(n),m=r,f=p["".concat(l,".").concat(m)]||p[m]||c[m]||a;return n?o.createElement(f,s(s({ref:t},u),{},{components:n})):o.createElement(f,s({ref:t},u))}));function m(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var a=n.length,s=new Array(a);s[0]=p;var i={};for(var l in t)hasOwnProperty.call(t,l)&&(i[l]=t[l]);i.originalType=e,i.mdxType="string"==typeof e?e:r,s[1]=i;for(var d=2;d<a;d++)s[d]=n[d];return o.createElement.apply(null,s)}return o.createElement.apply(null,n)}p.displayName="MDXCreateElement"},8487:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>s,default:()=>c,frontMatter:()=>a,metadata:()=>i,toc:()=>d});var o=n(7462),r=(n(7294),n(3905));const a={},s="Optimistic Updates",i={unversionedId:"docs/guides/optimistic-updates",id:"docs/guides/optimistic-updates",title:"Optimistic Updates",description:"The onStartMutation lifecycle hook can be used to update the cache before the mutation is sent. It gets passed the same",source:"@site/docs/docs/guides/08-optimistic-updates.md",sourceDirName:"docs/guides",slug:"/docs/guides/optimistic-updates",permalink:"/docs/guides/optimistic-updates",draft:!1,editUrl:"https://github.com/D-James-GH/cached_query/tree/main/docs/docs/docs/guides/08-optimistic-updates.md",tags:[],version:"current",sidebarPosition:8,frontMatter:{},sidebar:"docs",previous:{title:"Infinite Query",permalink:"/docs/guides/infinite-query"},next:{title:"Observer",permalink:"/docs/guides/observer"}},l={},d=[{value:"Rollback changes",id:"rollback-changes",level:2},{value:"Updating with received data",id:"updating-with-received-data",level:2}],u={toc:d};function c(e){let{components:t,...n}=e;return(0,r.kt)("wrapper",(0,o.Z)({},u,n,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"optimistic-updates"},"Optimistic Updates"),(0,r.kt)("p",null,"The ",(0,r.kt)("inlineCode",{parentName:"p"},"onStartMutation")," lifecycle hook can be used to update the cache before the mutation is sent. It gets passed the same\nargument you pass to mutate. "),(0,r.kt)("p",null,"The example below updates an infinite list and adds the new query to the start of the list. To make sure the data is in\nsync with the server it is also re-fetching the posts list once the mutation completes all in the background for improved\nUX."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-dart"},'Mutation<PostModel, PostModel>(\n  refetchQueries: ["posts"],\n  queryFn: (post) async {\n    final res = await _service.createPost(\n      title: post.title,\n      userId: post.userId,\n      body: post.body,\n    );\n    return PostModel.fromJson(res);\n  },\n  onStartMutation: (postArg) {\n    CachedQuery.instance.updateQuery(\n      key: "posts",\n      updateFn: (dynamic old) {\n        if (old is List<List<PostModel>>) {\n          return <List<PostModel>>[\n            [newPost, ...old[0]],\n            ...old.sublist(1).toList()\n          ];\n        }\n      },\n    );\n  },\n);\n')),(0,r.kt)("h2",{id:"rollback-changes"},"Rollback changes"),(0,r.kt)("p",null,"Anything that is returned from the ",(0,r.kt)("inlineCode",{parentName:"p"},"onStartMutation")," hook will be passed as the third argument to ",(0,r.kt)("inlineCode",{parentName:"p"},"onError")," allowing you\nto rollback changes if something fails."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-dart"},'Mutation<PostModel, PostModel> createPost() {\n  return Mutation<PostModel, PostModel>(\n    key: "createPost",\n    invalidateQueries: [\'posts\'],\n    queryFn: (post) async {\n      final res = await Future.delayed(\n        const Duration(milliseconds: 400),\n        () => {\n          "id": 123,\n          "title": post.title,\n          "userId": post.userId,\n          "body": post.body,\n        },\n      );\n      return PostModel.fromJson(res);\n    },\n    onStartMutation: (newPost) {\n      final query = CachedQuery.instance.getQuery("posts")\n          as InfiniteQuery<List<PostModel>, int>;\n\n      final fallback = query.state.data;\n      query.update(\n        (old) => [\n          [newPost, ...?old?.first],\n          ...?old?.sublist(1).toList()\n        ],\n      );\n\n      return fallback;\n    },\n    onSuccess: (args, newPost) {},\n    onError: (arg, error, fallback) {\n      CachedQuery.instance.updateQuery(\n        key: "posts",\n        updateFn: (dynamic old) => fallback as List<List<PostModel>>,\n      );\n    },\n  );\n}\n')),(0,r.kt)("p",null,"In the above example we optimistically update the posts query with a new entry and return the old data from ",(0,r.kt)("inlineCode",{parentName:"p"},"onStartMutation"),".\nIf the queryFn throws an error then we set the infinite query data to be the same as it was before the mutation."),(0,r.kt)("h2",{id:"updating-with-received-data"},"Updating with received data"),(0,r.kt)("p",null,"Often the response of a post request is the correct data, so you may want to update the cache after the mutation.\nUse ",(0,r.kt)("inlineCode",{parentName:"p"},"onSuccess")," to do just that."),(0,r.kt)("p",null,"The example below updated the cache after the mutation has completed using the response."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-dart"},'Mutation<PostModel, PostModel>(\n  refetchQueries: ["posts"],\n  queryFn: (post) async {\n    final res = await _service.createPost(\n      title: post.title,\n      userId: post.userId,\n      body: post.body,\n    );\n    return PostModel.fromJson(res);\n  },\n  onSuccess: (response, postArg) {\n    CachedQuery.instance.updateQuery(\n      key: "posts",\n      updateFn: (dynamic old) {\n        if(old is! List<List<PostModel>>) {\n          return old;\n        }\n        \n        return [\n          [response, ...old[0]],\n          ...old.sublist(1).toList()\n        ],\n      }\n    );\n  },\n);\n')))}c.isMDXComponent=!0}}]);