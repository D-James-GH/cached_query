"use strict";(self.webpackChunk=self.webpackChunk||[]).push([[582],{8453:(e,n,t)=>{t.d(n,{R:()=>s,x:()=>d});var a=t(6540);const i={},r=a.createContext(i);function s(e){const n=a.useContext(r);return a.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function d(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:s(e.components),a.createElement(r.Provider,{value:n},e.children)}},8960:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>c,contentTitle:()=>d,default:()=>o,frontMatter:()=>s,metadata:()=>a,toc:()=>l});const a=JSON.parse('{"id":"docs/guides/global-cache","title":"Global Cache","description":"The instance of the query cache is available through a singleton CachedQuery.instance. It has a few useful utilities on it.","source":"@site/docs/docs/guides/06-global-cache.md","sourceDirName":"docs/guides","slug":"/docs/guides/global-cache","permalink":"/docs/guides/global-cache","draft":false,"unlisted":false,"editUrl":"https://github.com/D-James-GH/cached_query/tree/main/docs/docs/docs/guides/06-global-cache.md","tags":[],"version":"current","sidebarPosition":6,"frontMatter":{},"sidebar":"docs","previous":{"title":"Mutations","permalink":"/docs/guides/mutations"},"next":{"title":"Infinite Query","permalink":"/docs/guides/infinite-query"}}');var i=t(4848),r=t(8453);const s={},d="Global Cache",c={},l=[{value:"Where Query",id:"where-query",level:2},{value:"Invalidate Queries",id:"invalidate-queries",level:2},{value:"Re-fetch, and Delete",id:"re-fetch-and-delete",level:2},{value:"Manually Adding and Removing Queries",id:"manually-adding-and-removing-queries",level:2},{value:"Updating the Cache",id:"updating-the-cache",level:2},{value:"Setting query data",id:"setting-query-data",level:3},{value:"Updating query data",id:"updating-query-data",level:3},{value:"Query Key Filter Function",id:"query-key-filter-function",level:2}];function h(e){const n={a:"a",admonition:"admonition",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",header:"header",p:"p",pre:"pre",...(0,r.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.header,{children:(0,i.jsx)(n.h1,{id:"global-cache",children:"Global Cache"})}),"\n",(0,i.jsxs)(n.p,{children:["The instance of the query cache is available through a singleton ",(0,i.jsx)(n.code,{children:"CachedQuery.instance"}),". It has a few useful utilities on it."]}),"\n",(0,i.jsx)(n.h2,{id:"where-query",children:"Where Query"}),"\n",(0,i.jsx)(n.p,{children:"Where query works much like where on an iterable. It returns a iterable of queries and infinite queries that satisfy the\ngiven test."}),"\n",(0,i.jsx)(n.p,{children:'The example below returns all queries/infinite queries whose key contains the word "Post".'}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.em,{children:"Note: The key on a query object will always be a string, the original key is accessible under unencodedKey"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-dart",children:'final queries = CachedQuery.instance.whereQuery((query) => query.key.contains("post"));\n'})}),"\n",(0,i.jsx)(n.h2,{id:"invalidate-queries",children:"Invalidate Queries"}),"\n",(0,i.jsxs)(n.p,{children:["Invalidating will mark the specified key as stale. By default ",(0,i.jsx)(n.code,{children:"invalidate"})," will refetch any query that has listeners.\nThe behavior can be changed by passing the ",(0,i.jsx)(n.code,{children:"refetchActive"})," (defaults to true) and ",(0,i.jsx)(n.code,{children:"refetchInactive"})," (defaults to false) parameters."]}),"\n",(0,i.jsx)(n.p,{children:"To invalidate the whole cache don't pass a key."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-dart",children:'CachedQuery.instance.invalidateCache(keys: ["posts"]);\n\n// or invalidate by finding a query\nCachedQuery.instance.whereQuery((q) => q.key.startsWith("todos/")).forEach((q) => q.invalidate());\n\n// Invalidate the whole cache\nCachedQuery.instance.invalidateCache();\n'})}),"\n",(0,i.jsx)(n.h2,{id:"re-fetch-and-delete",children:"Re-fetch, and Delete"}),"\n",(0,i.jsx)(n.p,{children:"Use the Cached Query instance to easily re-fetch the whole cache or a single key."}),"\n",(0,i.jsx)(n.p,{children:"Refetch multiple queries at once by passing a list of keys."}),"\n",(0,i.jsx)(n.admonition,{type:"info",children:(0,i.jsx)(n.p,{children:"Refetch is similar to invalidate however, it can ignore the stale duration and force a re-fetch."})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-dart",children:'CachedQuery.instance.refetchQueries(keys: ["posts"]);\n'})}),"\n",(0,i.jsx)(n.p,{children:"Refetch multiple queries at once by passing a filter."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-dart",children:'CachedQuery.instance.refetchQueries(\n    filterFn: (unencodedKey, key) => key.startsWith("todos/"),\n);\n'})}),"\n",(0,i.jsx)(n.p,{children:"Deleting will remove the specified key immediately. To delete the whole cache leave the key as null."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-dart",children:'// Optionally delete the stored values as well.\nCachedQuery.instance.deleteCache(key: "posts", deleteStorage: true);\n\n// Delete the whole cache\nCachedQuery.instance.deleteCache(deleteStorage: true);\n'})}),"\n",(0,i.jsx)(n.h2,{id:"manually-adding-and-removing-queries",children:"Manually Adding and Removing Queries"}),"\n",(0,i.jsx)(n.p,{children:"You can manually add or get a query from the cache, although it is not normally necessary to add it as the query will call\nthis for you."}),"\n",(0,i.jsx)(n.p,{children:"To add a query or infinite query to cache:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-dart",children:"CachedQuery.instance.addQuery(query);\n"})}),"\n",(0,i.jsx)(n.p,{children:"To get a query or infinite query from cache:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-dart",children:"CachedQuery.instance.getQuery(key);\n"})}),"\n",(0,i.jsx)(n.h2,{id:"updating-the-cache",children:"Updating the Cache"}),"\n",(0,i.jsxs)(n.p,{children:["It is often useful to be able to update the cache manually, for example, when performing ",(0,i.jsx)(n.a,{href:"/docs/guides/optimistic-updates",children:"optimistic updates"})]}),"\n",(0,i.jsx)(n.h3,{id:"setting-query-data",children:"Setting query data"}),"\n",(0,i.jsx)(n.p,{children:"Setting a query directly alters the data stored, if no query is available then one will be created."}),"\n",(0,i.jsxs)(n.p,{children:["If a new query is added using ",(0,i.jsx)(n.code,{children:"setQueryData"})," it will be created with an empty ",(0,i.jsx)(n.code,{children:"queryFn"}),". Any subsequent\nfetches will fail until a query or infinite query with the same key is created."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-dart",children:'\nCachedQuery.instance.setQueryData<String>(\n    key: "query_key",\n    data: "new_value",\n  );\n\nfinal query = CachedQuery.instance.getQuery("query_key");\n\n/// THIS WILL FAIL\nquery.refetch();\n\n'})}),"\n",(0,i.jsx)(n.p,{children:"To allow use of fetching, create an infinite query or query with the same key:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-dart",children:'final query = Query<String>(\n  key: "query_key",\n  queryFn: (_) async => "",\n);\n// WILL NOT FAIL\nquery.refetch();\n'})}),"\n",(0,i.jsx)(n.p,{children:"or for infinite query:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-dart",children:'final query = InfiniteQuery<String, int>(\n  key: "query_key",\n  getNextArg: (state) => (state?.length ?? 0) + 1,\n  queryFn: (_) async => "",\n);\n// WILL NOT FAIL\nquery.refetch();\n'})}),"\n",(0,i.jsx)(n.h3,{id:"updating-query-data",children:"Updating query data"}),"\n",(0,i.jsx)(n.p,{children:"Updating query data requires that a query already be present in the cache. It will not create a new\nquery if the key doesn't exist."}),"\n",(0,i.jsxs)(n.p,{children:["Use ",(0,i.jsx)(n.code,{children:"updateQuery"})," to update a query or an infinite query. Any changes will be emitted down the query stream.\nThe update function requires either a ",(0,i.jsx)(n.code,{children:"key"})," or a ",(0,i.jsx)(n.code,{children:"filterFn"})," to select the query to update. The ",(0,i.jsx)(n.code,{children:"updateFn"})," is then called with the current data and should return the new data."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-dart",children:'CachedQuery.instance.updateQuery(\n  key: "posts",\n  updateFn: (dynamic old) {\n    return InfiniteQueryData(\n        args: old?.args ?? [],\n        pages: [\n            [newPost, ...?old?.pages.first],\n            ...?old?.pages.sublist(1),\n        ],\n    );\n  },\n);\n'})}),"\n",(0,i.jsxs)(n.admonition,{type:"info",children:[(0,i.jsxs)(n.p,{children:["As an alternative to using ",(0,i.jsx)(n.code,{children:"CachedQuery.instance.updateQuery"})," you can also use the ",(0,i.jsx)(n.code,{children:"whereQuery"})," method in tandem with the ",(0,i.jsx)(n.code,{children:"update"})," method on the query object itself."]}),(0,i.jsx)(n.p,{children:"This would have better type safety but would result in more code."}),(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-dart",children:'CachedQuery.instance.whereQuery((q) => q.key == "posts").forEach((query) {\n    query.update(\n      (old) {\n        return InfiniteQueryData(\n          args: old?.args ?? [],\n          pages: [\n            [newPost, ...?old?.pages.first],\n            ...?old?.pages.sublist(1),\n          ],\n        );\n      },\n    );\n  },\n);\n'})})]}),"\n",(0,i.jsx)(n.h2,{id:"query-key-filter-function",children:"Query Key Filter Function"}),"\n",(0,i.jsxs)(n.p,{children:["Many of the functions on the CachedQuery instance take a key or a filterFn. A key is a direct reference to a cached query where as the ",(0,i.jsx)(n.code,{children:"filterFn"})," allows for selecting multiple queries at once."]}),"\n",(0,i.jsxs)(n.p,{children:["For example, say you have a list of todos, and each todo has been fetched with the key ",(0,i.jsx)(n.code,{children:'"todos/${id}"'}),', if a user selects a "complete all" button then we will want to find all the todos in the cache and update them, regardless of their id.']}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-dart",children:'CachedQuery.instance.updateQuery(\n  updateFn: (dynamic oldData){\n    if(oldData is Todo){\n      return oldData?.copyWith(complete: true);\n    }\n  },\n  filterFn: (unencodedKey, key) => key.startsWith("todos/"),\n);\n'})}),"\n",(0,i.jsxs)(n.p,{children:["Notice that the ",(0,i.jsx)(n.code,{children:"filterFn"})," passes through two arguments; ",(0,i.jsx)(n.code,{children:"unencodedKey"})," and ",(0,i.jsx)(n.code,{children:"key"}),". The ",(0,i.jsx)(n.code,{children:"unencodedKey"})," is the original key the you passed to the query. The ",(0,i.jsx)(n.code,{children:"key"})," is the json-encoded string of the ",(0,i.jsx)(n.code,{children:"unencodedKey"}),". Using the example above, if the todo keys were altered to be ",(0,i.jsx)(n.code,{children:'["todo", id]'})," then we could use the unencoded key to filter the queries."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-dart",children:'CachedQuery.instance.updateQuery<Todo>(\n  updateFn: (dynamic oldData){\n    if(oldData is Todo){\n      return oldData?.copyWith(complete: true);\n    }\n  },\n  filterFn: (unencodedKey, key) => unencodedKey is List && unencodedKey.first == "todo",\n);\n'})})]})}function o(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(h,{...e})}):h(e)}}}]);