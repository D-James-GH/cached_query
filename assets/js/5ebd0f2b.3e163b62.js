"use strict";(self.webpackChunk=self.webpackChunk||[]).push([[93],{1508:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>c,contentTitle:()=>l,default:()=>o,frontMatter:()=>r,metadata:()=>s,toc:()=>h});const s=JSON.parse('{"id":"docs/guides/infinite-query","title":"Infinite Query","description":"An infinite query is used to cache an infinite list, which is a common occurrence with mobile apps. The caching works","source":"@site/docs/docs/guides/07-infinite-query.md","sourceDirName":"docs/guides","slug":"/docs/guides/infinite-query","permalink":"/docs/guides/infinite-query","draft":false,"unlisted":false,"editUrl":"https://github.com/D-James-GH/cached_query/tree/main/docs/docs/docs/guides/07-infinite-query.md","tags":[],"version":"current","sidebarPosition":7,"frontMatter":{},"sidebar":"docs","previous":{"title":"Global Cache","permalink":"/docs/guides/global-cache"},"next":{"title":"Optimistic Updates","permalink":"/docs/guides/optimistic-updates"}}');var i=t(4848),a=t(8453);const r={},l="Infinite Query",c={},h=[{value:"Query Arguments",id:"query-arguments",level:2},{value:"Get Next Page",id:"get-next-page",level:2},{value:"Get Previous Page",id:"get-previous-page",level:2},{value:"Invalidation and Re-fetching",id:"invalidation-and-re-fetching",level:2},{value:"Side Effects",id:"side-effects",level:2},{value:"Local Cache",id:"local-cache",level:2}];function d(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",ul:"ul",...(0,a.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.header,{children:(0,i.jsx)(n.h1,{id:"infinite-query",children:"Infinite Query"})}),"\n",(0,i.jsx)(n.p,{children:"An infinite query is used to cache an infinite list, which is a common occurrence with mobile apps. The caching works\nin much the same way as a Query."}),"\n",(0,i.jsx)(n.p,{children:"Infinite query takes two generic arguments, the first being the data that will be returned from the queryFn and the\nsecond is the type of the argument that will be passed to the queryFn."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-dart",children:"final postsQuery = InfiniteQuery<List<PostModel>, int>(\n  key: 'posts',\n  getNextArg: (state) {\n    if (state.lastPage?.isEmpty ?? false) return null;\n    return state.length + 1;\n  },\n  queryFn: (page) => fetchPosts(endpoint: \"/api/data?page=${page}\"),\n);\n"})}),"\n",(0,i.jsx)(n.h2,{id:"query-arguments",children:"Query Arguments"}),"\n",(0,i.jsxs)(n.p,{children:["The function getNextArg will always be called before the query function. Whatever is returned from ",(0,i.jsx)(n.code,{children:"getNextArg"})," will be\npassed to the ",(0,i.jsx)(n.code,{children:"queryFn"}),"."]}),"\n",(0,i.jsxs)(n.p,{children:["If the return value of getNextArg is null the state on the infinite query will be set to\n",(0,i.jsx)(n.code,{children:"hasNextPage = false"}),". This will block further page calls."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-dart",children:"getNextArg: (state) {\n  // If the last page is null then no request has happened yet.\n  // If the last page is empty then the api has no more items.\n    if (state.lastPage?.isEmpty ?? false) return null;\n    return state.length + 1;\n},\n"})}),"\n",(0,i.jsxs)(n.p,{children:["The data of an infinite query will always be of type ",(0,i.jsx)(n.code,{children:"InfiniteQueryData"}),". For example, fetching a list of posts would result in type:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-dart",children:"\n/// An Interface for infinite query data.\nfinal class InfiniteQueryData<List<Post>, int> {\n  /// The pages of data returned from the queryFn\n  List<List<Post>> pages;\n\n  /// The arguments used to fetch the page of the same index\n  List<int> args;\n}\n"})}),"\n",(0,i.jsx)(n.h2,{id:"get-next-page",children:"Get Next Page"}),"\n",(0,i.jsxs)(n.p,{children:["To fetch the next page use ",(0,i.jsx)(n.code,{children:"infiniteQuery.getNextPage()"}),"."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-dart",children:"final postsQuery = InfiniteQuery<List<PostModel>, int>(\n  key: 'posts',\n  getNextArg: (state) {\n    if (state.lastPage?.isEmpty ?? false) return null;\n    return state.length + 1;\n  },\n  queryFn: (page) => fetchPosts(endpoint: \"/api/data?page=${page}\"),\n);\n---\nfinal nextPage = await postsQuery.getNextPage();\n"})}),"\n",(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.code,{children:"getNextPage"})," function returns a future of the infinite query state after the next page has completed. It is not\nnecessary to use the return value though, as the state will also be emitted down the query stream."]}),"\n",(0,i.jsxs)(n.p,{children:["Each request for ",(0,i.jsx)(n.code,{children:"getNextPage"})," will be de-duplicated, so only one page request can be made at a time. This normally reduces\nthe need for a throttle in an infinite list."]}),"\n",(0,i.jsx)(n.h2,{id:"get-previous-page",children:"Get Previous Page"}),"\n",(0,i.jsxs)(n.p,{children:["An infinite query can also fetch the previous page using ",(0,i.jsx)(n.code,{children:"infiniteQuery.getPreviousPage()"}),"."]}),"\n",(0,i.jsxs)(n.p,{children:["It works in the same way as ",(0,i.jsx)(n.code,{children:"getNextPage"})," but will use the ",(0,i.jsx)(n.code,{children:"getPreviousArg"})," function to get the argument for the previous page."]}),"\n",(0,i.jsxs)(n.p,{children:["Full example can be found: ",(0,i.jsx)(n.a,{href:"https://github.com/D-James-GH/cached_query/blob/main/examples/full/lib/posts/post_service.dart",children:"https://github.com/D-James-GH/cached_query/blob/main/examples/full/lib/posts/post_service.dart"})]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-dart",children:"\nInfiniteQuery<List<PostModel>, int> getPosts() {\n  return InfiniteQuery(\n    key: 'posts',\n    getNextArg: (state) {\n      // initial arg\n      if (state == null || state.args.isEmpty) return 5;\n\n      final lastArg = state.args.last;\n      return lastArg + 1;\n    },\n    getPrevArg: (state) {\n      final firstArg = state?.args.firstOrNull;\n      if (firstArg == null || firstArg <= 1) return null;\n      return firstArg - 1;\n    },\n    queryFn: (arg) async {\n       ///...fetch posts with arg\n    },\n  );\n}\n"})}),"\n",(0,i.jsx)(n.h2,{id:"invalidation-and-re-fetching",children:"Invalidation and Re-fetching"}),"\n",(0,i.jsx)(n.p,{children:"When an infinite query becomes stale it needs to be refreshed, just like a query. By default, each page will be refreshed sequentially, starting from the index 0.\nThis is the safest way to ensure the data is consistent."}),"\n",(0,i.jsxs)(n.p,{children:["However, if the number of pages is large this can take a long time. To adjust this behavior the property ",(0,i.jsx)(n.code,{children:"onPageRefetched"})," can be used.\nIf at anytime a value is returned from ",(0,i.jsx)(n.code,{children:"onPageRefetched"})," that value will be used as the new cache and no further pages will be refetched."]}),"\n",(0,i.jsx)(n.p,{children:"Here are two examples of how this can be used:"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsx)(n.li,{children:"If the first page is different only return the first page. This will reset the list to the first page only if the first page has changed. This prevents the whole list being refetched."}),"\n"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-dart",children:"final OnPageRefetched<T, Arg> onPageRefetched = (\n  T page,\n  InfiniteQueryData<T, Arg> currentResult,\n  InfiniteQueryData<T, Arg> cachedData,\n) {\n  if (page != cachedData.pages.firstOrNull && currentResult.pages.length == 1) {\n    return currentResult;\n  }\n  return null;\n}\n\n"})}),"\n",(0,i.jsxs)(n.ol,{start:"2",children:["\n",(0,i.jsx)(n.li,{children:"Only refetch the whole list if the first pages are different.\nUseful if a list is only added to at the start.\nIf the first page hasn't changed then the rest of the pages can be assumed to be the same."}),"\n"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-dart",children:"final OnPageRefetched<T, Arg> onPageRefetched = (\n  T page,\n  InfiniteQueryData<T, Arg> currentResult,\n  InfiniteQueryData<T, Arg> cachedData,\n) {\n  if (page == cachedData.pages.firstOrNull && currentResult.pages.length == 1) {\n    return cachedData;\n  }\n  return null;\n}\n\n"})}),"\n",(0,i.jsx)(n.h2,{id:"side-effects",children:"Side Effects"}),"\n",(0,i.jsx)(n.p,{children:"There are two side effects that can be passed to an infinite query."}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"onSuccess"})," - This is called after the query function succeeds but before the query state is updated."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"onError"})," - This is called if the query function fails but before the query state is updated."]}),"\n"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-dart",children:'final query = InfiniteQuery<String>(\n  key: "sideEffects",\n  onSuccess: (dynamic r) {\n    // do something with the response\n  },\n  onError: (dynamic e){\n    // do something with the error\n  },\n  queryFn: () async {\n    //...queryFn\n  },\n);\n'})}),"\n",(0,i.jsx)(n.h2,{id:"local-cache",children:"Local Cache"}),"\n",(0,i.jsx)(n.p,{children:"Each infinite query can take a local cache as a prop."}),"\n",(0,i.jsxs)(n.p,{children:["For more information, see ",(0,i.jsx)(n.a,{href:"/docs/guides/query#local-cache",children:"local cache"}),"."]})]})}function o(e={}){const{wrapper:n}={...(0,a.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(d,{...e})}):d(e)}},8453:(e,n,t)=>{t.d(n,{R:()=>r,x:()=>l});var s=t(6540);const i={},a=s.createContext(i);function r(e){const n=s.useContext(a);return s.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:r(e.components),s.createElement(a.Provider,{value:n},e.children)}}}]);