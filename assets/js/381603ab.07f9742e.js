"use strict";(self.webpackChunk=self.webpackChunk||[]).push([[345],{8221:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>c,default:()=>u,frontMatter:()=>i,metadata:()=>a,toc:()=>d});const a=JSON.parse('{"id":"docs/guides/query","title":"Query","description":"A query is used to cache single asynchronous requests in a unified and consistent way. The simplest form of a query is","source":"@site/docs/docs/guides/03-query.md","sourceDirName":"docs/guides","slug":"/docs/guides/query","permalink":"/docs/guides/query","draft":false,"unlisted":false,"editUrl":"https://github.com/D-James-GH/cached_query/tree/main/docs/docs/docs/guides/03-query.md","tags":[],"version":"current","sidebarPosition":3,"frontMatter":{"title":"Query"},"sidebar":"docs","previous":{"title":"Quick Start","permalink":"/docs/quick-start"},"next":{"title":"Configuration","permalink":"/docs/guides/configuration"}}');var s=t(4848),r=t(8453);const i={title:"Query"},c="Automatic Caching with Query",l={},d=[{value:"Query Key",id:"query-key",level:2},{value:"Query State",id:"query-state",level:3},{value:"Fetching Data",id:"fetching-data",level:2},{value:"Query Stream",id:"query-stream",level:2},{value:"Query Fetch",id:"query-fetch",level:2},{value:"Error Handling",id:"error-handling",level:2},{value:"Side Effects",id:"side-effects",level:2},{value:"Local Cache",id:"local-cache",level:2}];function h(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",ul:"ul",...(0,r.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.header,{children:(0,s.jsx)(n.h1,{id:"automatic-caching-with-query",children:"Automatic Caching with Query"})}),"\n",(0,s.jsx)(n.p,{children:"A query is used to cache single asynchronous requests in a unified and consistent way. The simplest form of a query is\nshown below. No global configuration is needed, although possible."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-dart",children:'final query = Query(\n  key: "my_data",\n  initialData: "Pre-populated data",\n  queryFn: () => api.getData(),\n);\n'})}),"\n",(0,s.jsxs)(n.p,{children:["Each Query must have a ",(0,s.jsx)(n.code,{children:"queryFn"})," and a key. The ",(0,s.jsx)(n.code,{children:"queryFn"})," is an asynchronous function that can return any value which will then be cached."]}),"\n",(0,s.jsx)(n.h2,{id:"query-key",children:"Query Key"}),"\n",(0,s.jsx)(n.p,{children:"A query must be given a unique key which can be any json serializable value. Each unique key will create a new query in\nthe cache. Initial data can be passed to the query. On the first request this initial data will be emitted as part of the state\nrather than null."}),"\n",(0,s.jsx)(n.p,{children:"Only one query will ever exist for each key. If a query is instantiated with a key that already exists the existing query will be returned."}),"\n",(0,s.jsx)(n.p,{children:"A good query key is important to ensure data is not overridden. Include any parameters and variable in a query key:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-dart",children:'String createPostKey(String id) => "post/$id";\n'})}),"\n",(0,s.jsx)(n.h3,{id:"query-state",children:"Query State"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"QueryStatus"})," is the sealed class containing the current state of the query."]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"QueryInitial"})," - The query has been created but the queryFn has not been called yet."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"QueryLoading"})," - The queryFn is currently running."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"QuerySuccess"})," - The queryFn has completed successfully and data is available."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"QueryError"})," - The queryFn has failed and an error is available."]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["The current data is available on all states. On the ",(0,s.jsx)(n.code,{children:"QuerySuccess"})," state the data will be the exact type of the generic passed in. On all other states\ndata will be nullable as there is a chance the queryFn hasn't returned anything yet."]}),"\n",(0,s.jsx)(n.h2,{id:"fetching-data",children:"Fetching Data"}),"\n",(0,s.jsx)(n.p,{children:"A query will not invoke the queryFn until one of two things is used:"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:["The ",(0,s.jsx)(n.code,{children:"fetch()"})," method is invoked"]}),"\n",(0,s.jsx)(n.li,{children:"A listener is added to the query stream."}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"query-stream",children:"Query Stream"}),"\n",(0,s.jsxs)(n.p,{children:["Each query manages its own stream controller. Streams enable a query to display currently existing data while fetching\nnew data in the background. When the new data is ready it will be emitted. A query stream will also emit any time the\nstate of the query is changed, this is useful for ",(0,s.jsx)(n.a,{href:"/docs/guides/mutations",children:"mutations"})," and\n",(0,s.jsx)(n.a,{href:"/docs/guides/optimistic-updates",children:"optimistic updates"}),"."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-dart",children:'final query = Query(key: "my_data", queryFn: () => api.getData());\n\nquery.stream((state) {\n  if(state.status == QueryStatus.loading){\n    // show loading spinner\n  }\n  if(state.data != null){\n    // update ui to show the data.\n  }\n});\n'})}),"\n",(0,s.jsx)(n.h2,{id:"query-fetch",children:"Query Fetch"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"Query.fetch()"})," is a quick and easy way to request the result of a queryFn. It returns ",(0,s.jsx)(n.a,{href:"#query-state",children:"QueryState"})," once\nthe queryFn has completed. For the full benefits of Cached Query use the stream api."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-dart",children:'final query = Query(key: "my_data", queryFn: () => api.getData());\n\nfinal queryState = await query.fetch();\n'})}),"\n",(0,s.jsx)(n.p,{children:"There are a few downsides to using a query this way. The future always completes after the queryFn has completed. If the\ndata is stale then nothing will show until fresh data is available, meaning you are not getting the benefits of\nbackground fetches."}),"\n",(0,s.jsxs)(n.p,{children:["As the Queries use streams to detect how many listeners they have left, using ",(0,s.jsx)(n.code,{children:"Query.fetch"})," never adds a\nlistener to the query. So, when the future is requested the ",(0,s.jsx)(n.a,{href:"/docs/guides/configuration",children:"cache duration"})," timer is started\nimmediately if there are no other listeners attached."]}),"\n",(0,s.jsx)(n.h2,{id:"error-handling",children:"Error Handling"}),"\n",(0,s.jsx)(n.p,{children:"If a query, infinite query or a mutation throws an error or exception it will be caught and the current state will be\nupdated with the error."}),"\n",(0,s.jsx)(n.h2,{id:"side-effects",children:"Side Effects"}),"\n",(0,s.jsx)(n.p,{children:"There are two side effects that can be passed to a query."}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"onSuccess"})," - This is called after the query function succeeds but before the query state is updated."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"onError"})," - This is called if the query function fails but before the query state is updated."]}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-dart",children:'final query = Query<String>(\n  key: "onSuccess",\n  onSuccess: (dynamic r) {\n    // do something with the response\n  },\n  onError: (dynamic e){\n    // do something with the error\n  },\n  queryFn: () async {\n    //...queryFn\n  },\n);\n'})}),"\n",(0,s.jsx)(n.h2,{id:"local-cache",children:"Local Cache"}),"\n",(0,s.jsxs)(n.p,{children:["By default, all queries will be saved inside the ",(0,s.jsx)(n.code,{children:"CachedQuery.instance"})," singleton. Most of the time this is enough.\nHowever, it may be useful to have full control of the cache for different areas of an app to prevent leaking sensitive\ninformation by not deleting the queries. Each query has a ",(0,s.jsx)(n.code,{children:"cache"})," prop which allows you to pass in specific instance of ",(0,s.jsx)(n.code,{children:"CachedQuery"}),"."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-dart",children:"final cache = CachedQuery.asNewInstance()\n  ..configFlutter();\n\nfinal query = Query(\n  cache: cache,\n  key: queryKey(id),\n  queryFn: () async {\n    final uri = Uri.parse(\n      'https://jsonplaceholder.typicode.com/posts/$id',\n    );\n    final res = await http.get(uri);\n    return PostModel.fromJson(\n      jsonDecode(res.body) as Map<String, dynamic>,\n    );\n  },\n);\n"})}),"\n",(0,s.jsxs)(n.p,{children:["A new instance of ",(0,s.jsx)(n.code,{children:"CachedQuery"})," can have a different config to the global one."]}),"\n",(0,s.jsxs)(n.p,{children:["If no cache is passed the query will be cached in the default ",(0,s.jsx)(n.code,{children:"CachedQuery.instance"})," singleton."]}),"\n",(0,s.jsxs)(n.p,{children:["A full example can be found here: ",(0,s.jsx)(n.a,{href:"https://github.com/D-James-GH/cached_query/tree/main/examples/multiple_caches",children:"https://github.com/D-James-GH/cached_query/tree/main/examples/multiple_caches"})]})]})}function u(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(h,{...e})}):h(e)}},8453:(e,n,t)=>{t.d(n,{R:()=>i,x:()=>c});var a=t(6540);const s={},r=a.createContext(s);function i(e){const n=a.useContext(r);return a.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function c(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:i(e.components),a.createElement(r.Provider,{value:n},e.children)}}}]);