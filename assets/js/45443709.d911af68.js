"use strict";(self.webpackChunk=self.webpackChunk||[]).push([[637],{6269:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>a,contentTitle:()=>l,default:()=>h,frontMatter:()=>o,metadata:()=>i,toc:()=>c});const i=JSON.parse('{"id":"examples/infinite-query","title":"Infinite List","description":"An infinite list is a great way to display information to a user. An infinite query can be used to increase the user experience","source":"@site/docs/examples/03-infinite-query.md","sourceDirName":"examples","slug":"/examples/infinite-query","permalink":"/examples/infinite-query","draft":false,"unlisted":false,"editUrl":"https://github.com/D-James-GH/cached_query/tree/main/docs/docs/examples/03-infinite-query.md","tags":[],"version":"current","sidebarPosition":3,"frontMatter":{},"sidebar":"examples","previous":{"title":"Flutter Bloc Query","permalink":"/examples/with-flutter-bloc"},"next":{"title":"Infinite List with Bloc","permalink":"/examples/infinite-list-with-bloc"}}');var s=t(4848),r=t(8453);const o={},l="Infinite List",a={},c=[{value:"The Setup",id:"the-setup",level:2},{value:"The Query",id:"the-query",level:2},{value:"The UI",id:"the-ui",level:2}];function d(e){const n={a:"a",admonition:"admonition",code:"code",h1:"h1",h2:"h2",header:"header",p:"p",pre:"pre",...(0,r.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.header,{children:(0,s.jsx)(n.h1,{id:"infinite-list",children:"Infinite List"})}),"\n",(0,s.jsx)(n.p,{children:"An infinite list is a great way to display information to a user. An infinite query can be used to increase the user experience\nwhen flicking between lists or pages. For example if you have a product list with multiple filters, why not cache each list\nso that the user doesn't have to wait when testing out new filters."}),"\n",(0,s.jsxs)(n.p,{children:["In this example we will use the ",(0,s.jsx)(n.a,{href:"https://jsonplaceholder.typicode.com/",children:"Json Placeholder Api"})," to demonstrate\nloading and caching data."]}),"\n",(0,s.jsxs)(n.p,{children:["The source code for this example can be found here: ",(0,s.jsx)(n.a,{href:"https://github.com/D-James-GH/cached_query/tree/main/examples/infinite_list",children:"https://github.com/D-James-GH/cached_query/tree/main/examples/infinite_list"})]}),"\n",(0,s.jsx)(n.h2,{id:"the-setup",children:"The Setup"}),"\n",(0,s.jsx)(n.p,{children:"Install the package."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"flutter pub add cached_query_flutter\n"})}),"\n",(0,s.jsx)(n.p,{children:"The setup is optional but to take full advantage of cached query we need to call the config function as early as possible."}),"\n",(0,s.jsxs)(n.p,{children:["The ",(0,s.jsx)(n.code,{children:"config"})," function lets cached query know that it should re-fetch queries if the connectivity is established and if\nthe app comes back into view."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-dart",children:"void main() {\n  WidgetsFlutterBinding.ensureInitialized();\n  CachedQuery.instance.configFlutter(\n    config: QueryConfigFlutter(\n      refetchOnResume: true,\n      refetchOnConnection: true,\n    ), \n    storage: await CachedStorage.ensureInitialized(),\n  );\n  runApp(const MyApp());\n}\n"})}),"\n",(0,s.jsx)(n.admonition,{type:"info",children:(0,s.jsxs)(n.p,{children:["Optionally set up ",(0,s.jsx)(n.a,{href:"/docs/storage",children:(0,s.jsx)(n.code,{children:"CachedStorage"})})," for persistence to disk. This step is shown above."]})}),"\n",(0,s.jsx)(n.p,{children:"The main app will just consist of one page. Which will be an infinite list."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-dart",children:"class MyApp extends StatelessWidget {\n  const MyApp({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return const MaterialApp(\n      title: 'Flutter Demo',\n      home: PostListScreen(),\n    );\n  }\n}\n"})}),"\n",(0,s.jsx)(n.h2,{id:"the-query",children:"The Query"}),"\n",(0,s.jsx)(n.p,{children:"We need to set up the query so that it requests a new page everytime the user scrolls to the bottom of the screen.\nTo do this we need to tell cached query how to calculate the arguments to pass to each page. For this example that is\nvery simple. The RestApi we are using just needs a page number as a query parameter, so we can calculate the args like this:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-dart",children:"getNextArg: (state) {\n  if (state.lastPage?.isEmpty ?? false) return null;\n  return state.length + 1;\n},\n"})}),"\n",(0,s.jsxs)(n.p,{children:["The argument we need to pass to get the next page is always going to be the number of pages currently in the cache plus 1.\nThe only difference is if the last page returned an empty list. If the last page is empty then we return null. By returning\nnull cached query knows that there are no more pages to be fetched and no more calls to ",(0,s.jsx)(n.code,{children:"getNextPage"})," will be called."]}),"\n",(0,s.jsxs)(n.p,{children:["In this example we are using ",(0,s.jsx)(n.code,{children:"CachedStorage"})," to persist the query to disk. As our cache is a dart object (PostModel) we\nneed to pass a ",(0,s.jsx)(n.code,{children:"storageDeserializer"})," function to the infinite query. If the storage has been set up when configuring ",(0,s.jsx)(n.code,{children:"CachedQuery"}),"\nand ",(0,s.jsx)(n.code,{children:"storageDeserializer"})," field is not null then it will be used to parse the data returned from disk back into a dart object."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-dart",children:"InfiniteQuery<List<PostModel>, int> getPosts() {\n  return InfiniteQuery<List<PostModel>, int>(\n    key: 'posts',\n    config: QueryConfig(\n      refetchDuration: const Duration(seconds: 2),\n      // use a serializer for cached storage\n      storageDeserializer: (dynamic postJson) {\n        return (postJson as List<dynamic>)\n            .map(\n              (dynamic page) => PostModel.listFromJson(page as List<dynamic>),\n        )\n            .toList();\n      },\n    ),\n    getNextArg: (state) {\n      if (state.lastPage?.isEmpty ?? false) return null;\n      return state.length + 1;\n    },\n    queryFn: (arg) async {\n      final uri = Uri.parse(\n        'https://jsonplaceholder.typicode.com/posts?_limit=10&_page=$arg',\n      );\n      final res = await http.get(uri);\n      return PostModel.listFromJson(\n        List<Map<String, dynamic>>.from(\n          jsonDecode(res.body) as List<dynamic>,\n        ),\n      );\n    },\n  );\n}\n"})}),"\n",(0,s.jsx)(n.h2,{id:"the-ui",children:"The UI"}),"\n",(0,s.jsxs)(n.p,{children:["The main list section of the UI is built using an ",(0,s.jsx)(n.code,{children:"InfiniteQuery"})," builder. This calls its builder function whenever the\nstate of the infinite query changes."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-dart",children:'InfiniteQueryBuilder<List<PostModel>, int>(\n  query: getPosts(),\n  builder: (context, state, query) {\n    final allPosts = state.data?.expand((e) => e).toList();\n    return CustomScrollView(\n      controller: _scrollController,\n      slivers: [\n        if (state.status == QueryStatus.error)\n        SliverToBoxAdapter(\n          child: DecoratedBox(\n          decoration:\n            BoxDecoration(color: Theme.of(context).errorColor),\n            child: Text(\n            state.error is SocketException\n              ? "No internet connection"\n                  : state.error.toString(),\n              style: const TextStyle(color: Colors.white),\n              textAlign: TextAlign.center,\n            ),\n          ),\n        ),\n        if (allPosts != null)\n        SliverList(\n          delegate: SliverChildBuilderDelegate(\n            (context, i) => Post(\n              post: allPosts[i],\n              index: i,\n            ),\n            childCount: allPosts.length,\n          ),\n        ),\n        if (state.status == QueryStatus.loading)\n        const SliverToBoxAdapter(\n          child: Center(\n            child: SizedBox(\n              height: 40,\n              width: 40,\n              child: CircularProgressIndicator(),\n            ),\n          ),\n        ),\n        SliverPadding(\n          padding: EdgeInsets.only(\n              bottom: MediaQuery.of(context).padding.bottom,\n          ),\n        )\n      ],\n  );\n}),\n'})}),"\n",(0,s.jsx)(n.p,{children:"The above builder will show different UI based on the current state of the query. For example, it will show a loading\nspinner at the bottom of the list when the state is loading."}),"\n",(0,s.jsxs)(n.p,{children:["When building an infinite list it is important to utilise some sort of lazy builder to prevent excess memory being used.\nThis could be a ",(0,s.jsx)(n.code,{children:"ListView.builder"})," or in this case to have more flexibility we are using a ",(0,s.jsx)(n.code,{children:"SliverList"})," with a\n",(0,s.jsx)(n.code,{children:"SliverChildBuilderDelegate"}),". This will only render the widgets within the viewport, which is especially important if\nthe list contains images."]}),"\n",(0,s.jsxs)(n.p,{children:["We also need to know when the list reaches the bottom so that we can request the next page. When the scroll controller\nhas reached 90% of the way down the ",(0,s.jsx)(n.code,{children:"getNextPage()"})," method is called. Notice that there is no throttle function needed.\nThe ",(0,s.jsx)(n.code,{children:"getNextPage"})," will only ever make one request at a time. It stores the current request in a future variable and always\nreturns the same future until it has completed. This prevents spamming."]}),"\n",(0,s.jsx)(n.p,{children:"The appbar and the list request the query in slightly different ways. The main List component calls the function that creates\nthe query directly. This will always return the same instance, as long as the key doesn't change. The appbar specifies\nthe query via the key. This only works because we know the query definitely exists as we are creating it on the same page."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-dart",children:"void _onScroll() {\n  final query = getPosts();\n  if (_isBottom && query.state.status != QueryStatus.loading) {\n    query.getNextPage();\n  }\n}\n  \nbool get _isBottom {\n  if (!_scrollController.hasClients) return false;\n  final maxScroll = _scrollController.position.maxScrollExtent;\n  final currentScroll = _scrollController.offset;\n  return currentScroll >= (maxScroll * 0.9);\n}\n"})}),"\n",(0,s.jsx)(n.p,{children:"All put together the full page looks like the following:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-dart",children:"class PostListScreen extends StatefulWidget {\n  static const routeName = '/';\n\n  const PostListScreen({Key? key}) : super(key: key);\n\n  @override\n  State<PostListScreen> createState() => _PostListScreenState();\n}\n\nclass _PostListScreenState extends State<PostListScreen> {\n  final _scrollController = ScrollController();\n\n  @override\n  void initState() {\n    super.initState();\n    _scrollController.addListener(_onScroll);\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(\n        title: InfiniteQueryBuilder(\n          queryKey: 'posts',\n          builder: (context, state, _) {\n            return Row(\n              children: [\n                if (state.status == QueryStatus.loading)\n                  const CircularProgressIndicator(\n                    valueColor: AlwaysStoppedAnimation<Color>(Colors.white),\n                  ),\n                const Text('posts'),\n              ],\n            );\n          },\n        ),\n        centerTitle: true,\n      ),\n      body: InfiniteQueryBuilder<List<PostModel>, int>(\n          query: getPosts(),\n          builder: (context, state, query) {\n            final allPosts = state.data?.expand((e) => e).toList();\n            return CustomScrollView(\n              controller: _scrollController,\n              slivers: [\n                if (state.status == QueryStatus.error)\n                  SliverToBoxAdapter(\n                    child: DecoratedBox(\n                      decoration:\n                          BoxDecoration(color: Theme.of(context).errorColor),\n                      child: Text(\n                        state.error is SocketException\n                            ? \"No internet connection\"\n                            : state.error.toString(),\n                        style: const TextStyle(color: Colors.white),\n                        textAlign: TextAlign.center,\n                      ),\n                    ),\n                  ),\n                if (allPosts != null)\n                  SliverList(\n                    delegate: SliverChildBuilderDelegate(\n                      (context, i) => _Post(\n                        post: allPosts[i],\n                        index: i,\n                      ),\n                      childCount: allPosts.length,\n                    ),\n                  ),\n                if (state.status == QueryStatus.loading)\n                  const SliverToBoxAdapter(\n                    child: Center(\n                      child: SizedBox(\n                        height: 40,\n                        width: 40,\n                        child: CircularProgressIndicator(),\n                      ),\n                    ),\n                  ),\n                SliverPadding(\n                  padding: EdgeInsets.only(\n                    bottom: MediaQuery.of(context).padding.bottom,\n                  ),\n                )\n              ],\n            );\n          }),\n    );\n  }\n\n  void _onScroll() {\n    final query = getPosts();\n    if (_isBottom && query.state.status != QueryStatus.loading) {\n      query.getNextPage();\n    }\n  }\n\n  bool get _isBottom {\n    if (!_scrollController.hasClients) return false;\n    final maxScroll = _scrollController.position.maxScrollExtent;\n    final currentScroll = _scrollController.offset;\n    return currentScroll >= (maxScroll * 0.9);\n  }\n\n  @override\n  void dispose() {\n    _scrollController\n      ..removeListener(_onScroll)\n      ..dispose();\n    super.dispose();\n  }\n}\n"})}),"\n",(0,s.jsx)(n.p,{children:"The Post widget is a simple stateless widget that displays the information held in the infinite query state."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-dart",children:"class Post extends StatelessWidget {\n  final PostModel post;\n  final int index;\n\n  const Post({Key? key, required this.post, required this.index})\n      : super(key: key);\n\n  @override\n  Widget build(BuildContext context) {\n    return Container(\n      padding: const EdgeInsets.symmetric(vertical: 10, horizontal: 10),\n      decoration: const BoxDecoration(\n        border: Border(bottom: BorderSide(color: Colors.black12)),\n      ),\n      child: Row(\n        children: [\n          Padding(\n            padding: const EdgeInsets.only(right: 8.0),\n            child: Text(index.toString()),\n          ),\n          Expanded(\n            child: Column(\n              crossAxisAlignment: CrossAxisAlignment.start,\n              children: [\n                Text(\n                  post.title,\n                  style: Theme.of(context).textTheme.headline6,\n                ),\n                Text(post.id.toString()),\n                Text(post.body),\n              ],\n            ),\n          ),\n        ],\n      ),\n    );\n  }\n}\n"})})]})}function h(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(d,{...e})}):d(e)}},8453:(e,n,t)=>{t.d(n,{R:()=>o,x:()=>l});var i=t(6540);const s={},r=i.createContext(s);function o(e){const n=i.useContext(r);return i.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:o(e.components),i.createElement(r.Provider,{value:n},e.children)}}}]);