"use strict";(self.webpackChunk=self.webpackChunk||[]).push([[49],{5145:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>r,default:()=>d,frontMatter:()=>o,metadata:()=>i,toc:()=>u});const i=JSON.parse('{"id":"docs/guides/mutations","title":"Mutations","description":"A mutation should be used to update data on the server. By its self a mutation doesn\'t really do anything. However, it","source":"@site/docs/docs/guides/05-mutations.md","sourceDirName":"docs/guides","slug":"/docs/guides/mutations","permalink":"/docs/guides/mutations","draft":false,"unlisted":false,"editUrl":"https://github.com/D-James-GH/cached_query/tree/main/docs/docs/docs/guides/05-mutations.md","tags":[],"version":"current","sidebarPosition":5,"frontMatter":{},"sidebar":"docs","previous":{"title":"Configuration","permalink":"/docs/guides/configuration"},"next":{"title":"Global Cache","permalink":"/docs/guides/global-cache"}}');var a=n(4848),s=n(8453);const o={},r="Mutations",l={},u=[{value:"Creating a mutation",id:"creating-a-mutation",level:2},{value:"Invalidating Queries",id:"invalidating-queries",level:2},{value:"Re-fetching Queries",id:"re-fetching-queries",level:2},{value:"Mutation Key and Cache",id:"mutation-key-and-cache",level:2},{value:"Mutation stream",id:"mutation-stream",level:3},{value:"Mutation Lifecycle",id:"mutation-lifecycle",level:2},{value:"Error handling",id:"error-handling",level:3}];function c(e){const t={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",p:"p",pre:"pre",ul:"ul",...(0,s.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(t.header,{children:(0,a.jsx)(t.h1,{id:"mutations",children:"Mutations"})}),"\n",(0,a.jsx)(t.p,{children:"A mutation should be used to update data on the server. By its self a mutation doesn't really do anything. However, it\ncomes with a few useful options for updating previously fetched queries."}),"\n",(0,a.jsx)(t.h2,{id:"creating-a-mutation",children:"Creating a mutation"}),"\n",(0,a.jsx)(t.p,{children:"A mutation is a small wrapper around a mutationFn which is an asynchronous function that will update the server. It takes two generic\narguments, the first is the mutationFn return type and the second is the argument type that will be passed to the mutationFn."}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-dart",children:"final createPostMutation = Mutation<ReturnType, ArgType>(\n  mutationFn: (post) => createPost(post),\n);\n"})}),"\n",(0,a.jsxs)(t.p,{children:["To activate a mutation call the mutate function on the ",(0,a.jsx)(t.code,{children:"Mutation"})," object."]}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-dart",children:'final post = PostModel(\n  title: "Post title",\n);\nawait createPostMutation.mutate(post);\n'})}),"\n",(0,a.jsxs)(t.p,{children:["The mutate function takes a single argument which must be the ",(0,a.jsx)(t.code,{children:"ArgType"})," specified when instantiating the mutation. This\nargument will be passed to the mutationFn. The mutate method returns a future that completes when the mutationFn completes,\nso this can be awaited if you need."]}),"\n",(0,a.jsx)(t.h2,{id:"invalidating-queries",children:"Invalidating Queries"}),"\n",(0,a.jsx)(t.p,{children:"It is often a good idea to invalidate all queries that the mutation will affect. To easily do this pass a list of query\nkeys when instantiating the mutation. If the mutation is successful all the queries matching the keys will be invalidated."}),"\n",(0,a.jsx)(t.p,{children:"Invalidation marks the query as stale and will re-fetch the query if it has listeners."}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-dart",children:"final createPostMutation = Mutation<PostModel, PostModel>(\n  invalidateQueries: ['posts'],\n  mutationFn: (post) => createPost(post),\n);\n"})}),"\n",(0,a.jsx)(t.h2,{id:"re-fetching-queries",children:"Re-fetching Queries"}),"\n",(0,a.jsxs)(t.p,{children:["To re-fetch a set of queries after a mutation completes pass a list of keys to the ",(0,a.jsx)(t.code,{children:"refetchQueries"})," prop. This will loop\nthrough the keys are force a re-fetch on each query."]}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-dart",children:"final createPostMutation = Mutation<PostModel, PostModel>(\n  refetchQueries: ['posts'],\n  mutationFn: (post) => createPost(post),\n);\n"})}),"\n",(0,a.jsx)(t.h2,{id:"mutation-key-and-cache",children:"Mutation Key and Cache"}),"\n",(0,a.jsx)(t.p,{children:"Unlike a query the mutation key is optional. A mutation will not be cached unless it is given a key. Caching a mutation\nis useful if the current state of the mutation is needed in multiple places. For example, you could have a loading spinner\nin the app bar while the mutation is called in a form submit button. In this case you would use a key to refer to the\nsame mutation."}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-dart",children:'final createPostMutation = Mutation<PostModel, PostModel>(\n  key: "post mutation",\n  mutationFn: (post) => createPost(post),\n);\n'})}),"\n",(0,a.jsx)(t.h3,{id:"mutation-stream",children:"Mutation stream"}),"\n",(0,a.jsxs)(t.p,{children:["Just like a query a mutation has a stream which emits the ",(0,a.jsx)(t.code,{children:"MutationState"})," whenever it changes. There is no ",(0,a.jsx)(t.code,{children:"cacheDuration"}),"\non a mutation so whenever the last listener is removed from a mutation it is immediately removed from memory."]}),"\n",(0,a.jsx)(t.h2,{id:"mutation-lifecycle",children:"Mutation Lifecycle"}),"\n",(0,a.jsx)(t.p,{children:"There are three lifecycle call backs for a mutation."}),"\n",(0,a.jsxs)(t.ul,{children:["\n",(0,a.jsxs)(t.li,{children:[(0,a.jsx)(t.code,{children:"onStartMutation"})," is called before the mutationFn. This can be used for ",(0,a.jsx)(t.a,{href:"/docs/guides/optimistic-updates",children:"optimistic updates"}),"."]}),"\n",(0,a.jsxs)(t.li,{children:[(0,a.jsx)(t.code,{children:"onSuccess"})," is called after the mutationFn if the mutation is successful."]}),"\n",(0,a.jsxs)(t.li,{children:[(0,a.jsx)(t.code,{children:"onError"})," is called after the mutationFn if the mutation fails."]}),"\n"]}),"\n",(0,a.jsx)(t.h3,{id:"error-handling",children:"Error handling"}),"\n",(0,a.jsxs)(t.p,{children:["The ",(0,a.jsx)(t.code,{children:"onError"})," callback is called if the mutationFn throws an error. Sometimes you may need to handle the error where you\ncall the ",(0,a.jsx)(t.code,{children:"mutate"})," function. To do this you can await the ",(0,a.jsx)(t.code,{children:"mutate"})," function and use the mutation state to view the error."]}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-dart",children:"final mutation = updateUser();\nawait mutation.mutate(user);\nif(mutation.state.status == QueryStatus.error){\n  // handle error\n}\n"})})]})}function d(e={}){const{wrapper:t}={...(0,s.R)(),...e.components};return t?(0,a.jsx)(t,{...e,children:(0,a.jsx)(c,{...e})}):c(e)}},8453:(e,t,n)=>{n.d(t,{R:()=>o,x:()=>r});var i=n(6540);const a={},s=i.createContext(a);function o(e){const t=i.useContext(s);return i.useMemo(function(){return"function"==typeof e?e(t):{...t,...e}},[t,e])}function r(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:o(e.components),i.createElement(s.Provider,{value:t},e.children)}}}]);